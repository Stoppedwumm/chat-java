/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.*;
import java.net.*;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList; // Import thread-safe list

// Server is now a class that manages the clients
public class Server {

    // Use an instance variable for the list of connected clients
    // CopyOnWriteArrayList is thread-safe for concurrent access
    private List<Socket> connectedClients = new CopyOnWriteArrayList<>();

    private int port;

    public Server(int port) {
        this.port = port;
    }

    public void start() {
        try (ServerSocket serverSocket = new ServerSocket(port)) { // Use try-with-resources for ServerSocket
            System.out.println("Server is listening on port " + port);

            while (true) {
                Socket clientSocket = serverSocket.accept(); // Accept a new client connection
                System.out.println("New client connected: " + clientSocket.getInetAddress().getHostAddress());

                // Add the new client to the thread-safe list
                connectedClients.add(clientSocket);

                // Handle client connection in a separate thread
                // Create an instance of a ClientHandler class
                new ClientHandler(clientSocket, connectedClients).start();
            }
        } catch (IOException ex) {
            System.err.println("Server exception: " + ex.getMessage());
            ex.printStackTrace();
        }
    }

    // Inner class (or separate class) to handle each client connection
    private class ClientHandler extends Thread {
        private Socket clientSocket;
        private List<Socket> clientList;
        private InputStream inputStream;
        private OutputStream outputStream;

        public ClientHandler(Socket socket, List<Socket> clientList) {
            this.clientSocket = socket;
            this.clientList = clientList; // Reference to the shared list
            try {
                this.inputStream = socket.getInputStream();
                this.outputStream = socket.getOutputStream();
            } catch (IOException e) {
                System.err.println("Error getting streams: " + e.getMessage());
            }
        }

        public void run() {
            System.out.println("Handling client: " + clientSocket.getInetAddress().getHostAddress());

            try {
                clientSocket.setKeepAlive(true);
                // Removed setSoTimeout(5000); - reading will block until data is available or connection is closed

                byte[] buffer = new byte[1024];
                int bytesRead;

                // Read from the client until -1 is returned (connection closed) or error occurs
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    // Process the data received from the client
                    String receivedData = new String(buffer, 0, bytesRead);
                    System.out.println("Received from " + clientSocket.getInetAddress().getHostAddress() + ": " + receivedData);

                    // Echo the data back to ALL clients
                    broadcastMessage(receivedData);

                    System.out.println("Processing client: " + clientSocket.getInetAddress().getHostAddress());
                }

                // If loop ends, the client disconnected gracefully
                System.out.println("Client disconnected gracefully: " + clientSocket.getInetAddress().getHostAddress());

            } catch (IOException ex) {
                // Handle exceptions like connection reset
                System.err.println("Client handling error for " + clientSocket.getInetAddress().getHostAddress() + ": " + ex.getMessage());
            } finally {
                // Clean up: close the socket and remove from the list
                try {
                    clientSocket.close();
                } catch (IOException e) {
                    System.err.println("Error closing client socket: " + e.getMessage());
                }
                // IMPORTANT: Remove the client from the shared list
                clientList.remove(clientSocket);
                System.out.println("Client removed. Total clients: " + clientList.size());
            }
        }

        // Method to send a message to all connected clients
        private void broadcastMessage(String message) {
             System.out.println("Broadcasting: " + message);
            // Iterate over the thread-safe list and send the message
            for (Socket client : clientList) {
                try {
                    // Check if the socket is still open before sending
                    if (client != null && !client.isClosed()) {
                        OutputStream clientOut = client.getOutputStream();
                        // Add a newline for readability in client terminal programs
                        clientOut.write((message + "\n").getBytes());
                        clientOut.flush(); // Ensure data is sent immediately
                    }
                } catch (IOException e) {
                    // If sending fails, the client is likely disconnected unexpectedly
                    System.err.println("Error sending message to client " + client.getInetAddress().getHostAddress() + ": " + e.getMessage());
                    // The client will be removed from the list when its handler thread detects the disconnect or throws an exception.
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the server
        Server server = new Server(12345);
        server.start();
    }
}